# 五种常用数据类型
string、list、hash、set、sorted set

## String
描述：
- value最大长度为512M
- 如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int 。
- 如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。
- 如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw。

常用方法
- `set key value`
- `setnx key value` # key不存在，才设置 = set key value nx
- `setxx key value` # key存在，才设置 = set key value xx
- `setex key seconds value` # 设置key的值，并设置过期时间
- `setpx key milliseconds value` # 设置key的值，并设置过期时间
- `get key`
- `del key`
- `mset key1 value1 key2 value2`
- `mget key1 key2`
- `incr key`
- `exists key`
- `expire key seconds`
- `pexpire key milliseconds`

应用场景：
- 缓存功能：string 最常用的就是缓存功能，会将一些更新不频繁但是查询频繁的数据缓存起来，以此来减轻 DB 的压力。
- 计数器：可以用来计数，通过 incr 操作，如统计网站的访问量、文章访问量等。

```shell
> redis_cli            # 启动redis-cli 客户端
> set hello world      # 将键 hello 的值设置为 world   
OK                     # set 命令成功后 会返回 OK
> get hello            # 通过 get 命令获取 键为 hello 的值
"world"                # 获得到的值
> del hello            # 删除键为 hello 的值
(integer) 1            # 返回的是删除的数量
> mset a 10 b 20 c 30  # 批量的设置值
OK
> mget a b c           # 批量的返回值
1)"10"
2)"20"
3)"30"
> exists hello         # 是否存在该键
(integer) 1            # 1 表示存在，0 表示不存在
> expire hello 10      # 给 hello 设置过期时间，单位，秒
(integer) 1            # 返回1代表成功，0代表key不存在或无法设置过期时间
> pexpire hello 10     # 给 hello 设置过期时间，单位，毫秒
(integer) 1            # 返回1代表成功，0代表key不存在或无法设置过期时间
```

```shell
# 使用 EX 选项
> set key1 hello EX 1000   # 设置 过期时间 1000s
OK
> ttl hello                # 获取 hello 的过期时间
(integer) 1000
# 使用 PX 选项
> set key1 hello PX 1000   # 设置 过期时间 1000ms
OK
> ttl hello                # 获取 hello 的过期时间
(integer) 1000
# 使用 NX 选项
> set hello world NX
OK                         # 键不存在，设置成功
> get hello
"value"
> set hello world NX
(nil)                      # 键已经存在，设置失败
> get hello
"world"                    # 维持原值不变
# 使用 XX 选项
> exists hello             # 先确定 hello 不存在
(integer) 0
> set hello world XX
(nil)                      # 因为键不存在，设置失败
> set hello wolrd          # 先给 hello 设置一个值
OK
> set hello newWolrd XX
OK                         # 这回设置成功了
> get hello
"newWorld"
# NX 或 XX 可以和 EX 或者 PX 组合使用
> set hello world EX 1000 NX
OK
> get hello
"world"
> ttl hello
(integer)1000
> set hello wolrd PX 30000 NX
OK
> pttl hello
(integer)30000          # 实际操作中 这个值肯定小于 30000，这次是为了效果才这么写的
# EX 和 PX 可以同时出现，但后面给出的选项会覆盖前面给出的选项
> set hello wolrd EX 1000 PX 30000
OK
> ttl hello
(integer)30            # 这个是 PX 设置的参数，
> pttl hello
(integer)30000
> set number 1
OK
> incr number          # 对 number 做自增操作
(integer) 2
```
在开发过程中，用 redis 来实现锁是很常用的操作。结合 NX 以及 EX 来实现。
```shell
> set hello world NX EX 10     # 成功加锁，过期时间是 10s
OK
> set hello wolrd NX EX 10     # 在10s内执行这个命令返回错误，因为上一次的锁还没有释放
(nil)
> del hello                    # 释放了锁
OK
> set hello world NX EX 10     # 成功加锁，过期时间是 10s
OK
> setnx hello world            # 也可以这么写
> setex hello 10 wolrd
```

## List
描述：
- 元素个数最多为2^32-1个，也就是4294967295个。
- 列表对象的编码可以是 ziplist 或者 linkedlist 。
- 列表对象保存的所有字符串元素的长度都小于 64 字节并且保存的元素数量小于 512 个，使用 ziplist 编码；否则使用 linkedlist；

常用方法：
- `lpush list value1 value2 ...`   # 将一个或多个值插入到列表的头部
- `rpush list value1 value2 ...`  # 将一个或多个值插入到列表的尾部
- `lpop list`                      # 移除并返回列表的第一个元素
- `rpop list`                      # 移除并返回列表的最后一个元素
- `llen list`                      # 返回列表的长度
- `lindex list index`              # 获取列表中指定位置的元素
- `lrange list start stop`         # 获取列表中指定范围内的元素
- `brpop list timeout`             # 从列表中弹出一个值，如果列表没有元素，会阻塞住，如果timeout秒后还是没有元素则返回
- `brpop list1 list2 timeout`      # 从列表中弹出一个值，并将弹出的值放入到另一个列表中，如果列表没有元素会阻塞列表直到等待超时或另一个列表中有元素被弹出

应用场景：
- 消息队列：Redis 的 list 是有序的列表结构，可以实现阻塞队列，使用左进右出的方式。Lpush 用来生产 从左侧插入数据，Brpop 用来消费，用来从右侧 阻塞的消费数据。
- 数据的分页展示： lrange 命令需要两个索引来获取数据，这个就可以用来实现分页，可以在代码中计算两个索引值，然后来 redis 中取数据。
- 可以用来实现粉丝列表以及最新消息排行等功能。

```shell
> lpush mylist a     # 从左边插入数据
(ineteger)1
> lpush mylist b
(integer)1
> rpush mylist c     # 从右边插入数据
(integer)1
> lrange mylist 0 -1 # 检索数据，lrange 需要两个索引，左闭右闭；0 就是从第 0 个，-1 是倒数第一个，-2 倒数第二个...以此类推
1)"b"
2)"a"
3)"c"
> lrange mylist 0 -2 # 0 到 倒数第 2 个 
1)"b"
2)"a"
> lpush mylist a b c # 批量插入
(integer)3
> lpop mylist        # 从左侧弹出元素
"b"
> rpop mylist        # 从右侧弹出元素
"c"
> rpop mylist        # 当列表中没有元素时返回 null
(nil)
> brpoop mylist 5    # 从右侧弹出元素，如果列表没有元素，会阻塞住，如果 5 s后还是没有元素则返回
1)"mylist"   # 列表名        
2)"b"        # 弹出元素
> del mylist         # 删除列表 
(integer)1
```

## Hash
描述：
- 键值对个数最多为2^32-1个，也就是4294967295个
- 哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节并且保存的键值对数量小于 512 个，使用ziplist 编码；否则使用hashtable；

常用方法
- `hset key field value`    # 将哈希表 key 中的域 field 的值设为 value
- `hget key field`          # 获取哈希表 key 中给定域 field 的值
- `hdel key field`          # 删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略
- `hlen key`                # 返回哈希表 key 中域的数量
- `hkeys key`               # 返回哈希表 key 中的所有域
- `hvals key`               # 返回哈希表 key 中的所有值

应用场景：
- Hash 更适合存储结构化的数据，比如 Java 中的对象；其实 Java 中的对象也可以用 string 进行存储，只需要将 对象 序列化成 json 串就可以，但是如果这个对象的某个属性更新比较频繁的话，那么每次就需要重新将整个对象序列化存储，这样消耗开销比较大。可如果用 hash 来存储 对象的每个属性，那么每次只需要更新要更新的属性就可以。
- 购物车场景：可以以用户的id为key，商品的id 为存储的field，商品数量为键值对的value，这样就构成了购物车的三个要素。

```shell
> hset student name 张三    # 可以理解为忘名叫student的map中添加 kv 键值对
(integer)1            # 返回1 代表 不存在这个key，并且添加成功
> hset student sex 男
(integer)1
> hset student name 张三
(integer)0            # 返回0 因为这个key已经存在
> hgetall student
1)"name"
2)"张三"
3)"sex"
4)"男"
> hdel student name       #删除这key
(integer)1           # 返回 1 同样代表整个 key 存在 并且删除成功
> hdel student name
(integer)0           # 返回 0 是因为 该 key 已经不存在
```

## Set
描述
- 元素个数最多为2^32-1个，也就是4294967295个。
- 集合对象保存的所有元素都是整数值并且保存的元素数量不超过 512 个，使用intset 编码；否则使用hashtable；

常用方法
- `sadd key value` # 添加
- `smembers key` # 列出
- `sismember key value` # 判断是否存在

```shell
> sadd family mother          # 尝试将 mother 添加进 family 集合中
(integer)1       # 返回 1 表示添加成功，0 表示元素已经存在集合中
> sadd family father
(integer)1
> sadd family father
(intger)0
> smembers family             # 获取集合中所有的元素
1)"mother"
2)"father"
> sismember family father     # 判断 father 是否在 family 集合中 
(integer)1      # 1 存在；0 不存在
> sismber family son
(integer)0
> srem family son             # 移除 family 集合中元素 son
(integer)1     # 1 表示存在并且移除成功;0 表示存在该元素
> srem family som
(integer)0
> sadd family1 mother
(integer)1
> smembers family 
1)"mother"
2)"father"
> smember family1
1)"mother"
> sinter family family1     # 获取 family 和 family1 的交集
1)"mother"
> sadd family1 son
(integer)1
> sunion family family1     # 获取 family 和 family1 的并集
1)"mother"
2)"father"
> sdiff family family1      # 获取 family 和 family1 的差集（就是family有但是family1没有的元素）
1)"father"
```

# 三种高级数据类型
HyperLogLog、Geo、BloomFilter