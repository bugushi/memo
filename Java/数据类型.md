### 数组
两种初始化方式
```java
dataType[] arrayRefVar = new dataType[arraySize];
```

```java
dataType[] arrayRefVar = {value0, value1, ..., valuek};
```

### 自动装箱 / 自动拆箱
- 赋值时从基础类型提升（自动装箱）
- 比较、运算等操作从包装类型向基础类型跌落（自动拆箱）
> java对Integer的自动装箱与拆箱会用到享元模式， 为了加大对简单数字的重利用，java对从-128到127的值进行缓存，实际上是调用了Integer.valueof方法，在Integer的静态内部类IntegerCache中对-128到127的数字进行了缓存

> 如果用new去创建对象就会生成新对象。

> 另外还有String，Short，Long， Byte， Character使用了缓存； 浮点数并没有使用缓存。
``` java
Integer a = 1;
Integer b = 1;
System.out.println(a == b); // true

Integer c = 444;
Integer d = 444;
System.out.println(c == d); // false
```
参考：

[自动装箱拆箱中的享元模式](https://www.jianshu.com/p/3c300b5ecece)

[深入浅出java常量池](https://www.cnblogs.com/syp172654682/p/8082625.html)

[String.intern()，将字符串注入常量池](https://www.cnblogs.com/Qian123/p/5707154.html)

### 什么是RawTypes
```java
List list = new ArrayList(); // raw type
List<Integer> listIntgrs = new ArrayList<>(); // parameterized type
```

### `Array` 和 `ArrayList`
- Array定长、定类型；
- ArrayList变长、泛型

### `HashMap` 和 `HashTable`
键值对，HashMap允许null键和null值，异步线程不安全

HashMap将键entry(键值对)取hash，存在默认16个桶中，分配在同一个桶中的entry使用链表结构，同一个桶中超过8个entry，则改为红黑树，以提高查询性能

> Default initial capacity of the HashMap takes is 16 and load factor is 0.75f (i.e 75% of current map size). The load factor represents at what level the HashMap capacity should be doubled.

> For example product of capacity and load factor as 16 * 0.75 = 12. This represents that after storing the 12th key – value pair into the HashMap , its capacity becomes 32.
